-<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
<html lang="uk-ua">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="keywords" lang="uk-ua" content="tkinter,Python">
    <link rel="icon" type="image/png" href="../../16.ico">
    <title>Tkinter</title>
</head>
<body style="text-align:justify;">
    <font face="ubuntu, calibri" size="+2">
        <center>
            <b>
                <font face="ubuntu, calibri" size="+4">Бібліотека tkinter мови Python</font>
            </b>
        </center>
        <p>

            <b>
                <font face="ubuntu, calibri" size="+3">Зміст</font>
            </b>
        </p>
        <ol>
            <li>
                <a href="#general">Загальні поняття</a>
            </li>
            <li>
                <a href="#import">Імпорт tkinter і виклик циклу опрацювання подій</a>
            </li>
            <li>
                <a href="#properties">Створення елемента керування</a>
            </li>
            <li>
                <a href="#colors">Назви кольорів</a>
            </li>
            <li>
                <a href="#common">Cпільні методи віджетів</a>
            </li>
            <li>
                <a href="#noncommon">«Системні» (не віджет-специфічні) методи</a>
            </li>
            <li>
                <a href="#main">Основні елементи керування</a>
                <ul>
                    <li>
                        <a href="#Toplevel">Toplevel</a>
                         — вікно верхнього рівня
                    </li>
                    <li>
                        <a href="#Button">Button</a>
                         — кнопка
                    </li>
                    <li>
                        <a href="#Label">Label</a>
                         — напис без можливості редагування
                    </li>
                    <li>
                        <a href="#Entry">Entry</a>
                         — для введення рядка тексту
                    </li>
                    <li>
                        <a href="#Text">Text</a>
                         — для введення багаторядкового тексту
                    </li>
                    <li>
                        <a href="#Listbox">Listbox</a>
                         — список для вибору одного або кількох пунктів
                    </li>
                    <li>
                        <a href="#Frame">Frame</a>
                         — рамка
                    </li>
                    <li>
                        <a href="#Checkbutton">Checkbutton</a>
                         — елемент списку з місцем для мітки
                    </li>
                    <li>
                        <a href="#Radiobutton">Radiobutton</a>
                         — перемикач
                    </li>
                    <li>
                        <a href="#Scale">Scale</a>
                         — шкала для вибору значення з діапазону
                    </li>
                    <li>
                        <a href="#Scrollbar">Scrollbar</a>
                         — для «прокручування» іншого елемента керування
                    </li>
                </ul>
            </li>
            <li>
                <a href="#сanvas">Canvas</a>
                 — виведення зображень на полотно
            </li>
            <li>
                <a href="#packs">Розташування елементів  за допомогою пакувальників</a>
                <ul>
                    <li>
                        <a href="#pack">pack</a>
                    </li>
                    <li>
                        <a href="#grid">grid</a>
                    </li>
                    <li>
                        <a href="#place">place</a>
                    </li>
                </ul>
            </li>
            <li>
                <a href="#events">Опрацювання подій</a>
                <ul>
                    <li>
                        <a href="#bind">bind</a>
                         — пов'язування віджета, події і обробника події
                    </li>
                    <li>
                        <a href="#nameform">форми назв подій</a>
                    </li>
                    <li>
                        <a href="#pass">передавання додаткового аргумента методом bind</a>
                    </li>
                    <li>
                        <a href="#eventstypes">вбудовані події</a>
                    </li>
                    <li>
                        <a href="#bind_add">додаткові методи *bind*</a>
                    </li>
                </ul>
            </li>
            <li>
                <a href="#image">Зображення</a>
            </li>
            <li>
                <a href="#dialog">Вікна діалогу</a>
                <ul>
                    <li>
                        <a href="#messagebox">messagebox</a>
                    </li>
                    <li>
                        <a href="#filedialog">filedialog</a>
                    </li>
                    <li>
                        <a href="#simpledialog">simpledialog</a>
                    </li>
                    <li>
                        <a href="#colorchooser">colorchooser</a>
                    </li>
                </ul>
            </li>
            <li>
                <a href="#ttk">Розширення ttk</a>
            </li>
            <li>
                <a href="#examle">Приклад: примітивний текстовий редактор</a>
            </li>
        </ol>
        <p>
            <a href="#links">Посилання</a>
            <br>
            <br>

            <a name="general"></a>
            <b>
                <font face="ubuntu, calibri" size="+3">1. Загальні поняття</font>
            </b>
            <br>
            <br>
            <b>Tkinter</b>
             (від англійського Tk interface) — це 
            <i>багатоплатформна</i>
             (Windows, Linux, Mac OS X і інші) 
            <i>
                бібліотека мови Python, що є інтерфейсом до 
                <a href="http://tcl.tk" target="_blank">tcl / tk</a>
                 і слугує для створення програм з графічним інтерфейсом.
            </i>
            <br>
            <br>

            <b>Tcl (Tool Command Language)</b>
             — це 
            <i>потужна багатоплатформна мова програмування веб- і настільних застосунків, роботи мережі, адмініст&shy;рування, тестування тощо.</i>
            <br>
            <br>

            <b>Tk</b>
             — 
            <i>це графічний набір інструментів для створення інтерфейсу на вищому від традиційних підходів рівні. Придатний не лише для Tcl, але і для багатьох інших динамічних мов.</i>
            <br>
            <br>

            <b>Віджет</b>
             (widget, від англійського Window gadget) — 
            <i>елемент керування — стандартизований компонент графічного інтерфейсу, з яким взаємодіє користувач.</i>
            <br>
            <br>

            <a name="Tk">
                <b>Клас Tk</b>
            </a>
             — 
            <i>основний клас застосунку Tkinter.</i>
             При створенні об'єкта цього класу буде завантажено інтерпретатор tcl/tk і створено основне вікно програми.
            <br>
            <br>


            Tkinter є 
            <i>подійно-орієнтованою</i>
             бібліотекою. При її використанні головним є цикл опрацювання подій. У tkinter такий цикл:
        </p>
        <ul>
            <li>

                запускають на виконання методом 
                <i>mainloop;</i>
            </li>
            <li>

                завершують методом 
                <i>quit.</i>
            </li>
        </ul>
        <p>

            <a name="import"></a>
            <b>
                <font face="ubuntu, calibri" size="+3">2. Імпорт tkinter і виклик циклу опрацювання подій</font>
            </b>
            <br>
            <br>

            Імпорт tkinter здійснюють таким самим чином, як і будь-якої іншої бібліотек, але по різному для різних версій Python:
        </p>
        <ul>
            <li>
                <tt>import Tkinter</tt>
                 — для версії python 2.7 і нижче;
            </li>
            <li>
                <tt>import tkinter</tt>
                 — для версії python 3.0 і вище,
            </li>
        </ul>


        або

        <tt>from Tkinter import *</tt>
         — для версії python 2.7 і нижче;</li>
        <li>
            <tt>from tkinter import *</tt>
             — для версії python 3.0 і вище,
        </li>
        </ul>
        <p>

        Дія мінімальної програми з tkinter:</p>
        <tt>
            <pre>
            from tkinter import *
            root = Tk ()
            root.mainloop ()</pre>
        </tt>
        <p>
        буде такою:</p>
        <center>
            <img src="01.png">
        </center>
        <p>

        Можна використовувати кілька викликів інтерпретатора tcl/tk. Після виклику методу mainloop подальші вказівки python не буде виконано до виходу з цього циклу опрацювання подій. Тому методи mainloop, крім останнього, потрібно здійснювати у режимі тла. Наприклад, таким чином:</p>
        <tt>
            <pre>
            from tkinter import *
            root1 = Tk ()
            root2 = Tk ()
            root1.after (500, root1.mainloop)
            root2.mainloop ()</pre>
        </tt>
        <center>
            <img src="02.png">
        </center>
        <p>


            При використанні двох чи більше викликів інтерпретатора 
            <i>необхідно, щоб об'єкти, створені в одному циклі mainloop, було використано лише в ньому.</i>
             Необхідність використання кількох циклів у одному застосунку виникає вкрай рідко. Для створення додаткового вікна програми у більшості випадків досить віджета Toplevel.
            <br>
            <br>

            <b>Примітка</b>
            . Для того, щоб використовувати літери кирилиці, потрібно використовувати рядки з кодуванням Unicode. У Python 2.x для цього потрібно перед рядком писати літеру u. Також у першому чи другому рядку файлу необхідно вказати (в коментарі) кодування файлу:
            <br>
            <br>
            <tt>

                # Encoding: utf-8
                <br>
                <br>
            </tt>

            У Python 3.x цього робити не потрібно, бо всі рядки в ньому мають кодування Unicode.
            <br>
            <br>

            <a name="properties"></a>
            <font size=+3>
                <b>3. Створення елемента керування</b>
            </font>
            <br>
            <br>

            Елементи керування (віджети) створюють викликом конструктора відповідного класу.
            <br>
            <br>


            Першим у переліку аргументів-властивостей (зазвичай без назви, але можна використовувати назву master) вказують батьківський віджет, в який буде упаковано (поміщено) створюваний віджет. Батьківський віджет можна не вказувати. У такому випадку буде використано головне вікно програми.
            <br>
            <br>


            Далі задають значення властивостей-аргументи:
        </p>
        <ul>
            <li>

                використовуваний шрифт (
                <tt>font = …</tt>
                );
            </li>
            <li>

                колір тла віджета (
                <tt>bg = …</tt>
                );
            </li>
            <li>

                вказівка, яку буде виконано при активуванні віджета (
                <tt>command = …</tt>
                )
            </li>
        </ul>
        <p>

        тощо. Розглянемо приклад коду з використанням конструктора Button для кнопок button1 і button2:</p>
        <tt>
            <pre>
            from tkinter import *
            def button_clicked ():
                print("Клац!")
            root = Tk ()

            # Кнопка як усталено
            button1 = Button()  # створення кнопки button1
            button1.pack()      # розташування кнопки button1 на головному вікні

            # Кнопка із зазначенням батьківського віджета й кількома аргументами
            button2 = Button (root, bg = "red", text = "Натисни мене!", command = button_clicked)  # створення кнопки button2
            button2.pack ()     # розташування кнопки button2 на головному вікні
            root.mainloop ()</pre>
        </tt>
        <center>
            <img src="03.png">
        </center>
        <p>

        Після трьох клацань отримаємо таке:</p>
        <center>
            <img src="04.png">
        </center>
        <p>

            <a name="colors"></a>
            <font size=+3>
                <b>4. Назви кольорів</b>
            </font>
            <br>
            <br>


            Однією з властивостей елемента керування є bg — колір тла. Подану далі таблицю з назвами кольорів отримано з використанням 
            <a href="12.txt" target="_blank">коду</a>
            , запозиченого зі 
            <a href="http://www.science.smith.edu/dftwiki/index.php/Color_Charts_for_TKinter" target="_blank">сторінки</a>
             сайту Smith College.
        </p>
        <center>
            <img src="59.png">
        </center>
        </p>


        Крім 
        <a href="http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm" target="_blank">усталених назв кольорів</a>
         можна використати довільний колір моделі RGB, записавши рядком у форматі "#RRGGBB", де RR, GG, BB — інтенсивності відповідно червоного, зеленого і блакитного кольорів, записані у системі числення з основою 16.
        <br>
        <br>

        <a name="common"></a>
        <font size=+3>
            <b>5. Cпільні методи віджетів</b>
        </font>
        </p>
        <ul>
            <li>
                <p>
                    <b>configure</b>
                     (синонім config) — 
                    <i>для зміни конфігурації віджета під час виконання програми.</i>
                     Альтернатива:
                    <br>
                    <br>
                    <tt>
                        <i>назва_віджета</i>
                        [ '
                        <i>назва властивості</i>
                        '] = 
                        <i>нове_значення</i>
                        <br>
                        <br>
                    </tt>


                    Приклад виведення поточного часу після клацання по кнопці:
                </p>
                <tt>
                    <pre>
                    from tkinter import *
                    import time
                    def button_clicked ():
                        button['text'] = time.strftime('%H:%M:%S')
                    root   = Tk()
                    button = Button(root)
                    button.configure(text=time.strftime('%H:%M:%S'),command=button_clicked)
                    # Альтернатива:
                    # Button ['text'] = time.strftime ('%H:%M:%S')
                    # Button [ 'command']=button_clicked
                    button.pack ()
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="05.png">
                </center>
                <p>

                У поданому коді функцію button_clicked буде викликано, щойно користувач клацне по кнопці.</p>
            </li>
            <li>
                <p>

                    <b>cget</b>
                     — обернений до методу configure і призначений для 
                    <i>отримання даних про конфігурацію віджета.</i>
                </p>
                <tt>
                    <pre>
                    from tkinter import *
                    root = Tk()
                    w = Label(root, text="Проба пера")
                    w.pack()
                    print(w.cget('text'))
                    root.mainloop()</pre>
                </tt>
                <center>
                    <img src="06.png">
                </center>
                <p>

                    Як і у випадку з configure, є альтернатива:
                    <br>
                    <br>
                    <tt>
                        <i>назва_змінної</i>
                         = 
                        <i>назва_віджета</i>
                        ['
                        <i>назва_властивості</i>
                        ']
                    </tt>
                </p>
            </li>
            <li>
                <p>

                    <b>destroy</b>
                     — 
                    <i>знищення віджета і всіх його нащадків.</i>
                     Якщо потрібно лише на час заховати будь-якої віджет, то краще використати пакувальник grid і метод grid_remove. Наприклад, таким чином:
                </p>
                <tt>
                    <pre>
                    from tkinter import *
                    def hide_show ():
                        if label.winfo_viewable ():
                           label.grid_remove ()
                        else:
                           label.grid ()
                    root = Tk ()
                    label = Label (text='Я тут! ')
                    label.grid ()
                    button = Button (command = hide_show, text = "Сховати / показати")
                    button.grid ()
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="07.png">
                    <img src="08.png">
                </center>
            </li>
            <li>
                <p>

                    <b>grab_*</b>
                     — 
                    <i>керуванням потоком події.</i>
                     Віджет, який захопив потік, буде отримувати всі події вікна або програми:
                </p>
                <ul>
                    <li>
                        <p>
                            <b>grab_set</b>
                             — 
                            <i>передати потік даному віджету;</i>
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>grab_set_global</b>
                             — 
                            <i>передати глобальний потік даному віджету.</i>
                             В цьому випадку 
                            <i>всі</i>
                             події (на моніторі) буде передано лише цьому віджету, а 
                            <i>інші віджети всіх застосунків не отримуватимуть повідомлення про події;</i>
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>grab_release</b>
                             — 
                            <i>звільнити потік;</i>
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>grab_status</b>
                             — 
                            <i>дізнатися поточний статус потоку подій для віджета</i>
                             (можливі значення: None, "local" або "global");
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>grab_current</b>
                             — 
                            <i>отримати віджет, який отримує потік;</i>
                        </p>
                    </li>
                </ul>
                <p>
                Див. приклад захоплення глобального потоку й вивільнення його за 10 секунд. Протягом цих десяти секунд, наприклад, неможливо буде змінити розміри вікон програм.</p>
                <tt>
                    <pre>
                    from tkinter import *
                    root = Tk ()
                    root.after (200, root.grab_set_global)
                    root.after (10000, root.grab_release)
                    root.mainloop ()</pre>
                </tt>
                <p>
                Проявом роботи цієї програми буде також поява вікна, яке створює мінімальна програма.</p>
                <center>
                    <img src="01.png">
                </center>
            </li>
            <li>
                <p>

                    <a name="focus"></a>
                    <b>focus_*</b>
                     — 
                    <i>керування фокусом введення з клавіатури.</i>
                     Віджет, який має фокус, отримує всі події з клавіатури:
                </p>
                <ul>
                    <li>
                        <p>
                            <b>focus</b>
                             (синонім focus_set) — 
                            <i>передавання фокусу віджету;</i>
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>focus_force</b>
                             — 
                            <i>перевання фокусу, навіть якщо застосунок не має фокусу;</i>
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>focus_get</b>
                             — 
                            <i>повернення віджету, на який спрямовано фокус,</i>
                             або None, якщо такого немає;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>focus_displayof</b>
                             — 
                            <i>повернення віджету, на який спрямовано фокус на тому дисплеї, на якому розташовано віджет,</i>
                             або None, якщо такого немає;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>focus_lastfor</b>
                             — 
                            <i>повернення віджету, на який буде спрямовано фокус, коли вікно з цим віджетом отримає фокус;</i>
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>tk_focusNext</b>
                             — 
                            <i>повернення віджету, який отримає фокус наступним</i>
                             (зазвичай зміна фокуса відбувається при натисканні клавіші Tab). Порядок проходження визначено  послідовністю пакування віджетів;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>tk_focusPrev</b>
                             — 
                            <i>повернення віджету, який мав фокус до поточного стану;</i>
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>tk_focusFollowsMouse</b>
                             — 
                            <i>надання віджету властивості отримувати фокус при наведенні на нього миші.</i>
                             При цьому повернути нормальну поведінку досить складно.
                        </p>
                    </li>
                </ul>
            </li>
        </ul>
        <p>

            <a name="noncommon"></a>
            <font size=+3>
                <b>6. «Системні» (не віджет-специфічні) методи</b>
            </font>
            <br>
            <br>

            Наступні методи впливають на роботу інтерпретатора tcl/tk.</i>
        </p>
        <ul>
            <li>
                <p>
                    <b>Tаймери</b>
                     — 
                    <i>за допомогою цих методів можна відкласти виконання якого-небудь коду на певний час:</i>
                </p>
                <ul>
                    <li>
                        <p>
                            <b>after</b>
                             — має два аргументи: час у мілісекундах і функцію, яку потрібно виконати через вказаний час. Повертає ідентифікатор, який можна використати у методі  after_cancel (див. далі);
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>after_idle</b>
                             — має лише один аргумент — функцію, яку буде виконано після завершення всіх відкладених операцій (тобто після того, як будуть опрацьовані всі події), повертає ідентифікатор, який може бути використаний в after_cancel;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>after_cancel</b>
                             — має лише один аргумент — ідентифікатор завдання, отриманий попередніми функціями. Скасовує це завдання.
                        </p>
                    </li>
                </ul>
                <p>
                Див. приклад (годинник):</p>
                <tt>
                    <pre>
                    from tkinter import *
                    import time
                    def tick ():
                        label.after (200, tick)
                        label [ 'text'] = time.strftime('%H:%M:%S')
                    root = Tk ()
                    label = Label (font = 'sans 20')
                    label.pack ()
                    label.after_idle (tick)
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="09.png">
                </center>
            </li>
            <li>
                <p>

                    <b>Функції для роботи з чергою завдань:</b>
                </p>
                <ul>
                    <li>
                        <p>

                            <b>update_idletasks</b>
                            <i>виконує завдання, відкладені «на потім»</i>
                             — на час, коли застосунок буде простоювати. Як правило цю функцію використовують при внесенні змін у стан застосунку і є потреба негайного відображення на екрані цих змін без очікування завершення сценарію;
                        </p>
                    </li>
                    <li>
                        <p>

                            <b>update</b>
                            <i>опрацьовує всі завдання, які стоять у черзі.</i>
                             Як правило її використовують під час «важких» розрахунків, коли необхідно залишити програму чутливою до дій користувача. Див. приклад.
                        </p>
                        <tt>
                            <pre>
                            from tkinter import *
                            import math
                            def hard_job ():
                                x = 1000
                                while True:
                                    x = math.log (x) ** 2.8
                                    root.update ()
                            root = Tk ()
                            button = Button ()
                            button.pack ()
                            root.after (500, hard_job)
                            root.mainloop ()</pre>
                        </tt>
                    </li>
                </ul>
            </li>
            <li>
                <p>

                    <b>Функції для виконання коду мовою tcl:</b>
                </p>
                <ul>
                    <li>
                        <b>eval</b>
                         — 
                        <i>виконати рядок мовою tcl;</i>
                    </li>
                    <li>
                        <b>evalfile</b>
                         — 
                        <i>виконати код мовою tcl, записаний у файл.</i>
                    </li>
                </ul>
                <p>

                Аргументи цих функцій — відповідно рядок (з вказівками) чи шлях до файлу.</p>
            </li>
        </ul>
        <p>

            <a name="main"></a>
            <font size=+3>
                <b>7. Основні елементи керування</b>
            </font>
        </p>
        <ul>
            <li>
                <p>

                    <a name="Toplevel">
                        <b>Toplevel</b>
                    </a>
                     — 
                    <i>вікно верхнього рівня, яке використовують для створення багатовіконних програм, а також вікон діалогу.</i>
                     Має такі методи (їх можна застосувати також і до кореневого вікна root):
                </p>
                <ul>
                    <li>
                        <p>
                            <b>title</b>
                             — 
                            <i>заголовок вікна;</i>
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>overrideredirect</b>
                             — 
                            <i>вказівка ​менеджеру вікон ігнорувати це вікно.</i>
                             Аргументом є True або False. Якщо аргумент не вказано, буде отримано поточне значення. Якщо аргумент має значення True, то таке вікно буде показано без обрамлення, тобто без заголовка і бордюру;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>iconify / deiconify</b>
                             — 
                            <i>згорнути / розгорнути вікно;</i>
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>withdraw</b>
                             — 
                            <i>«заховати» (зробити невидимим) вікно.</i>
                             Для того, щоб знову показати вікно, потрібно використовувати метод deiconify;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>minsize</b>
                             і 
                            <b>maxsize</b>
                             — 
                            <i>мінімальний / максимальний розмір вікна.</i>
                             Методи мають два аргументи: ширина й висота вікна. Якщо не вказано жодних аргументів, методи повертають поточне значення;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>state</b>
                             — 
                            <i>отримати поточне значення стану вікна.</i>
                             Може повертати такі значення: normal (нормальний стан), icon (показано у вигляді іконки), iconic (згорнуто), withdrawn (не показано), zoomed (розгорнуто на повний екран — лише для Windows і Mac OS X);
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>resizable</b>
                             — 
                            <i>вказівка на те, чи може користувач змінювати розмір вікна.</i>
                             Має два аргументи — можливість зміни розміру по горизонталі і по вертикалі. Без аргументів повертає поточне значення;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>geometry</b>
                             — 
                            <i>встановлює геометрію вікна</i>
                             у форматі ширина&times;висота + 
                            <i>x</i>
                             + 
                            <i>y</i>
                            . Наприклад,
                            <br>
                            <br>
                            <tt>

                                geometry ("600x400 + 40 + 80")
                                <br>
                                <br>
                            </tt>

                            означає таке: помістити вікно у точку з координатами (40,80) і встановити розмір 600&times;400). Розмір або координати можна не вказувати:
                        </p>
                        <ul>
                            <li>
                                <tt>geometry("600x400")</tt>
                                 — лише змінити розмір,
                            </li>
                            <li>
                                <tt>geometry("+ 40 + 80")</tt>
                                 — лише перемістити вікно);
                            </li>
                        </ul>
                    </li>
                    <li>
                        <p>
                            <b>transient</b>
                             — 
                            <i>зробити вікно залежним від іншого вікна,</i>
                             зазначеного в аргументі: буде згортатися разом із зазначеним вікном. Без аргументів повертає поточне значення;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>protocol</b>
                             — 
                            <i>отримує два аргументи: назву події та функцію, яка буде викликатися при настанні вказаної події.</i>
                             Події можуть мати такі назви:
                        </p>
                        <ul>
                            <li>
                            WM_TAKE_FOCUS — отримання фокусу;</li>
                            <li>
                            WM_DELETE_WINDOW — видалення вікна;</li>
                        </ul>
                    </li>
                    <li>
                        <p>
                            <b>tkraise</b>
                             (синонім 
                            <b>lift</b>
                            ) / 
                            <b>lower</b>
                             — 
                            <i>піднімає (розміщує поверх всіх інших вікон) / опускає вікно.</i>
                             Методи можуть приймати один необов'язковий аргумент: назву вікна, над / під яким потрібно розмістити поточне;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>grab_set</b>
                             — 
                            <i>встановлює фокус на вікно, навіть при наявності відкритих інших вікон;</i>
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>grab_release</b>
                             — 
                            <i>знімає монопольне володіння фокусом введення з вікна.</i>
                        </p>
                    </li>
                </ul>
                <p>

                Приклад:</p>
                <tt>
                    <pre>
                    from tkinter import *
                    def w_d ():
                        print('Вікно закрито')
                        root.quit () # вихід з програми
                    root = Tk ()
                    root.title ('Приклад застосування')
                    root.geometry('350x100+300+450') # ширина = 350,
                                                     # висота = 100,
                                                     # x = 300,
                                                     # y = 450
                    root.protocol('WM_DELETE_WINDOW',w_d) # обробник закриття вікна
                    root.resizable (False,True) # розмір можна змінити лише по вертикалі
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="10.png">
                    <br>
                    <br>
                    <img src="11.png">
                </center>
            </li>
            <li>
                <p>

                    <a name="Button">
                        <b>Button</b>
                    </a>
                     — 
                    <i>кнопка,</i>
                     яку розглянемо на прикладі дії коду:
                </p>
                <tt>
                    <pre>
                    from tkinter import *
                    root = Tk ()
                    button1 = Button (root, text='Текст', width=10, height=3, bg='blue', fg='yellow', font='ubuntu 24')
                    button1.pack ()
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="12.png">
                    <img src="13.png">
                </center>
                <p>

                Розберемо цей код. За створення вікна, відповідає клас Tk. У першу чергу потрібно створити екземпляр цього класу. Зазвичай його називають root, хоча його можна назвати як завгодно. Далі створено кнопку з вказанням її властивості:</p>
                <ul>
                    <li>
                    root — назва вікна розташування;</li>
                    <li>
                    text — напис на кнопці;</li>
                    <li>

                        width, height — ширина й довжина</i>
                         (у знакомісцях);
                    </li>
                    <li>
                    bg — колір (скорочено від background);</li>
                    <li>
                    fg — колір напису (скорочено від foreground);</li>
                    <li>
                    font — шрифт і його розмір.</li>
                </ul>
                <p>

                Далі кнопку розташовано на вікні з допомогою найпростішого пакувальника (методу) pack (про пакувальники pack, place і grid див. далі). В кінці програми використано метод mainloop — цикл опрацю&shy;вання подій.</p>
            </li>
            <li>
                <p>

                    <a name="Label">
                        <b>Label</b>
                    </a>
                     — 
                    <i>напис без можливості редагування його користувачем.</i>
                     Має ті самі властивості, що і перераховані вище властивості кнопки.
                </p>
            </li>
            <li>
                <p>

                    <a name="Entry">
                        <b>Entry</b>
                    </a>
                     — це елемент керування для введення 
                    <i>одного рядок тексту.</i>
                     Має додаткові (порівняно з Button і Label) такі властивості:
                </p>
                <ul>
                    <li> 
                    borderwidth — ширина бордюру (межі);</li>
                    <li>
                    bd — скорочення від borderwidth;</li>
                    <li>
                    show — відображувані символи.</li>
                </ul>
            </li>
            <li>
                <p>

                    <a name="Text">
                        <b>Text</b>
                    </a>
                     — це елемент керування для введення довільного багаторядкового тексту. Має (додаткову) властивість wrap, що відповідає за перенесення. Щоб переносити словами, потрібно надати їй значення WORD — див. приклад без ознак кінця рядка (при його введенні не натискали на клавішу 
                    <i>Enter</i>
                    ).
                </p>
                <tt>
                    <pre>
                    from tkinter import *
                    root = Tk ()
                    text1 = Text (root, height=7, width=7, font='ubuntu 14', wrap=WORD, bd=5)
                    text1.pack ()
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="14.png">
                </center>
                <p>

                Методи insert, delete і get відповідно додають, видаляють або витягають текcт. Перший аргумент — місце вставлення у вигляді 'x.y', де x — це рядок, а y — стовпчик. Див. приклади:</p>
                <tt>
                    <pre>
                    text1.insert('1.0','Додати цей текст \ n \ в початок першого рядка')
                    text1.delete('1.0',END) # Видалити все
                    text1.get   ('1.0',END) # Витягти  все</pre>
                </tt>
            </li>
            <li>
                <p>

                    <a name="Listbox">
                        <b>Listbox</b>
                    </a>
                     — 
                    <i>список, з елементів якого користувач може вибирати один або кілька пунктів.</i>
                     Має (додаткову) властивість selectmode, що може набувати таких значень:
                </p>
                <ul>
                    <li>
                    SINGLE — можливий вибір лише одного елемента списку;</li>
                    <li>
                    EXTENDED — можливий вибір довільної кількості елементів списку.</li>
                </ul>
                <p>
                Приклад застосування із заповненням списку:</p>
                <tt>
                    <pre>
                    from tkinter import *
                    root = Tk ()
                    listbox1 = Listbox (root, height=3, width=15, selectmode = EXTENDED)
                    listbox2 = Listbox (root, height=5, width=15, selectmode = SINGLE)
                    list1 = ["Київ","Харків","Одеса","Львів"]
                    list2 = ["Галич","Збараж","Теребовля","Тернопіль"]
                    for i in list1:
                        listbox1.insert (END, i)
                    for i in list2:
                        listbox2.insert (END, i)
                    listbox1.pack ()
                    listbox2.pack ()
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="30.png">
                    <img src="31.png">
                </center>
            </li>
            <li>
                <p>

                    <a name="Frame">
                        <b>Frame</b>
                    </a>
                     — 
                    <i>рамка для організації віджетів всередині вікна</i>
                    , використання якої розглянемо на такому прикладі:
                </p>
                <tt>
                    <pre>
                    from tkinter import *
                    root = Tk ()
                    frame1  = Frame (root, bg = 'green', bd = 5)
                    frame2  = Frame (root, bg = 'red',   bd = 5)
                    button1 = Button (frame1, text = 'Кнопка 1')
                    button2 = Button (frame2, text = 'Кнопка 2')
                    frame1.pack ()
                    frame2.pack ()
                    button1.pack ()
                    button2.pack ()
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="15.png">
                </center>
            </li>
            <li>
                <p>

                    <a name="Checkbutton">
                        <b>Checkbutton</b>
                    </a>
                     — 
                    <i>елемент списку з місцем для мітки</i>
                    . Значення кожної мітки (прапорця) пов'язано зі своєю змінною. 
                    Значення цієї змінної властивістю onvalue (ввімкнено) і offvalue (вимкнено). При використанні кількох елементів списку потрібно для кожного використати свою змінну — див. приклад:
                </p>
                <tt>
                    <pre>
                    from tkinter import *
                    root = Tk ()
                    var1 = IntVar ()
                    var2 = IntVar ()
                    check1 = Checkbutton (root, text = '1 пункт ', variable = var1, onvalue = 1, offvalue = 0)
                    check2 = Checkbutton (root, text = '2 пункт ', variable = var2, onvalue = 0, offvalue = 1)
                    check1.pack ()
                    check2.pack ()
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="16.png">
                </center>
            </li>
            <li>
                <p>

                    <a name="Radiobutton">
                        <b>Radiobutton</b>
                    </a>
                     — 
                    <i>перемикач</i>
                     — елемент списку з місцем для мітки за умови можливості виставити лише одну мітку. Перемикач завжди використовують у групі, причому увімкненим може бути лише один перемикач. Реалізація цього віджета відрізняється від реалізації для Checkbutton:
                </p>
                <tt>
                    <pre>
                    from tkinter import *
                    root = Tk ()
                    v    = IntVar ()
                    rbutton1 = Radiobutton (root, text='Варіант 1', variable=v, value=1)
                    rbutton2 = Radiobutton (root, text='Варіант 2', variable=v, value=2)
                    rbutton3 = Radiobutton (root, text='Варіант 3', variable=v, value=3)
                    rbutton1.pack ()
                    rbutton2.pack ()
                    rbutton3.pack ()
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="17.png">
                </center>
                <p>
                Тут:</p>
                <ul>
                    <li>
                        <p>
                        IntVar — клас для роботи с цілими числами;</p>
                    </li>
                    <li>
                        <p>
                        variable — властивість, що описує прикріплення до віджета змінної;</p>
                    </li>
                    <li>
                        <p>
                        onvalue, offvalue — властивості, які надають прикріпленій до віджету змінній значение залежно від стану:</p>
                        <ul>
                            <li>
                            onvalue — при вибраному пункті;</li>
                            <li>
                            offvalue — при невибраному пункті).</li>
                        </ul>
                    </li>
                </ul>
                <p>

                У цьому прикладі використано лише одну змінну. Залежно від того, який пункт обрано, вона змінює своє значення. Найцікавіше, що якщо надати цій змінній якесь значення, то зміниться і сам віджет.</p>
            </li>
            <li>
                <p>

                    <a name="Scale">
                        <b>Scale</b>
                    </a>
                     — 
                    <i>шкала для вибору довільного значення із заданого діапазону.</i>
                     Має такі властивості:
                </p>
                <ul>
                    <li>

                        orient — розташування з можливими значеннями:
                        <ul>
                            <li>
                            HORIZONTAL — горизонтально;</li>
                            <li>
                            VERTICAL — вертикально;</li>
                        </ul>
                    </li>
                    <li>
                    length — довжина шкали;</li>
                    <li>
                    from_ — значення, з якого починається шкала;</li>
                    <li>
                    to — значення, яким закінчується шкала;</li>
                    <li>
                    tickinterval — інтервал між мітками шкали;</li>
                    <li>

                        resolution — крок пересування повзунка.</p>
                    </li>
                </ul>
                <p>

                див. приклад використання:</p>
                <tt>
                    <pre>
                    from tkinter import *
                    root = Tk()
                    def getV(root):
                        a = scale1.get()
                        print ("Отримане значення :", a) 
                    scale1 = Scale(root,orient=HORIZONTAL,length=300,from_=50,to=80,tickinterval=5,resolution=1)
                    button1 = Button(root,text="Отримати значення")
                    scale1.pack()
                    button1.pack()
                    button1.bind("&lt;Button-1&gt;",getV)
                    root.mainloop()</pre>
                </tt>
                <center>
                    <img src="18.png">
                    <img src="19.png">
                    <br>
                    <br>
                    <img src="20.png">
                </center>
                </p>


                Тут використано метод get, щоб отримати з віджета значення і використати його за межами Scale.</p>
            </li>
            <li>
                <p>

                    <a name="Scrollbar">
                        <b>Scrollbar</b>
                    </a>
                     — «прокручування» іншого віджету, наприклад, текстового поля. При використанні необхідно зробити дві прив'язки властивостей:
                </p>
                <ul>
                    <li>
                        <p>
                        command смуги прокрутки — до методу xview / yview віджета;</p>
                    </li>
                    <li>
                        <p>
                        xscrollcommand / yscrollcommand віджета — до методу set смуги прокрутки</p>
                    </li>
                </ul>
                <p>

                — див. приклад:</p>
                <tt>
                    <pre>
                    from tkinter import *
                    root = Tk ()
                    text = Text (root, height = 3, width = 20)
                    text.pack (side = 'left')
                    scrollbar = Scrollbar (root)
                    scrollbar.pack (side = 'left')
                    scrollbar ['command'] = text.yview      # Прив'язування 1
                    text ['yscrollcommand'] = scrollbar.set # Прив'язування 2
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="21.png">
                </center>
            </li>
        </ul>
        <p>

            <a name="сanvas"></a>
            <font size=+3>
                <b>8. Canvas — виведення зображень на полотно</b>
            </font>
            <br>
            <br>

            <b>Canvas (полотно) </b>
             — 
            <i>це об'єкт класу ТCanvas для виведення зображень, які можна змінювати і переміщати у процесі виконання програми.</i>
            <br>
            <br>


            На полотні можна розташувати такі об'єкти 
            <font color="navy">(у дужках вказано назви властивостей для полегшення пошуку довідкової інформації)</font>
            :
        </p>
        <ul>
            <li>
                <p>
                    <b>arc</b>
                     — 
                    <i>дуга</i>
                    <font color=navy>
                    (activedash,
                    activefill,
                    activeoutline,
                    activeoutlinestipple,
                    activestipple,
                    activewidth,
                    dash,
                    dashoffset,
                    disableddash,
                    disabledfill,
                    disabledoutline,
                    disabledoutlinestipple,
                    disabledstipple,
                    disabledwidth,
                    extent,
                    fill,
                    offset,
                    outline,
                    outlineoffset,
                    outlinestipple,
                    start,
                    state,
                    stipple,
                    style,
                    tag,
                    tags,
                    width)</font>
                    ;
                </p>
            </li>
            <li>
                <p>
                    <b>bitmap</b>
                     — 
                    <i>двоколірне зображення</i>
                    <font color=navy>
                    (activebackground,
                    activebitmap,
                    activeforeground,
                    anchor,
                    background,
                    bitmap,
                    disabledbackground,
                    disabledbitmap,
                    disabledforeground,
                    foreground,
                    state,
                    tags)</font>
                    ;
                </p>
            </li>
            <li>
                <p>
                    <b>image</b>
                     — 
                    <i>багатоколірне зображення</i>
                    <font color=navy>
                    (activeimage,
                        anchor,
                        disabledimage,
                        image,
                        state,
                        tags)</font>
                    ;
                </p>
            </li>
            <li>
                <p>
                    <b>line</b>
                     — 
                    <i>відрізок прямої</i>
                    <font color=navy> 
                    (activedash,
                        activefill,
                        activestipple,
                        activewidth,
                        arrow,
                        arrowshape,
                        capstyle,
                        dash,
                        dashoffset,
                        disableddash,
                        disabledfill,
                        disabledstipple,
                        disabledwidth,
                        fill,
                        joinstyle,
                        offset,
                        smooth,
                        splinesteps,
                        state,
                        stipple,
                        tags,
                        width)</font>
                    ;
                </p>
            </li>
            <li>
                <p>
                    <b>oval</b>
                     — 
                    <i>коло або еліпс</i>
                    <font color=navy>
                    (activedash,
                        activefill,
                        activeoutline,
                        activeoutlinestipple,
                        activestipple,
                        activewidth,
                        dash,
                        dashoffset,
                        disableddash,
                        disabledfill,
                        disabledoutline,
                        disabledoutlinestipple,
                        disabledstipple,
                        disabledwidth,
                        fill,
                        offset,
                        outline,
                        outlineoffset,
                        outlinestipple,
                        state,
                        stipple,
                        tags,
                        width)</font>
                    ;
                </p>
            </li>
            <li>
                <p>
                    <b>polygon</b>
                     — 
                    <i>многокутник</i>
                    <font color=navy> 
                    (activedash,
                        activefill,
                        activeoutline,
                        activeoutlinestipple,
                        activestipple,
                        activewidth,
                        dash,
                        dashoffset,
                        disableddash,
                        disabledfill,
                        disabledoutline,
                        disabledoutlinestipple,
                        disabledstipple,
                        disabledwidth,
                        fill,
                        joinstyle,
                        offset,
                        outline,
                        outlineoffset,
                        outlinestipple,
                        points,
                        smooth,
                        splinesteps,
                        state,
                        stipple,
                        tags,
                        width)</font>
                    ;
                </p>
            </li>
            <li>
                <p>
                    <b>rectangle</b>
                     — 
                    <i>прямокутник</i>
                    <font color=navy> 
                       (activedash,
                        activefill,
                        activeoutline,
                        activeoutlinestipple,
                        activestipple,
                        activewidth,
                        dash,
                        dashoffset,
                        disableddash,
                        disabledfill,
                        disabledoutline,
                        disabledoutlinestipple,
                        disabledstipple,
                        disabledwidth,
                        fill,
                        offset,
                        outline,
                        outlineoffset,
                        outlinestipple,
                        state,
                        stipple,
                        tags,
                        width)</font>
                    ;
                </p>
            </li>
            <li>
                <p>
                    <b>text</b>
                     — 
                    <i>текст</i>
                    <font color=navy> 
                    (activefill,
                        activestipple,
                        anchor,
                        disabledfill,
                        disabledstipple,
                        fill,
                        font,
                        justify,
                        offset,
                        state,
                        stipple,
                        tags,
                        text,
                        width)</font>
                    ;
                </p>
            </li>
            <li>
                <p>
                    <b>window</b>
                     — 
                    <i>вікно</i>
                    <font color=navy> 
                    (anchor,
                        height,
                        state,
                        tags,
                        width,
                        window)</font>
                    ;
                </p>
            </li>
        </ul>
        <p>

        Подамо приклади (щоб побачити програму, потрібно клацнути на малюнку лівою кнопкою миші):</p>
        <center>
            <a href="05.txt" target="_blank">
                <img src="50.png" align=top>
            </a>
            <a href="06.txt" target="_blank">
                <img src="51.png" align=top>
            </a>
            <a href="06.txt" target="_blank">
                <img src="52.png" align=top>
            </a>
            <a href="07.txt" target="_blank">
                <img src="53.png" align=top>
            </a>
            <a href="11.txt" target="_blank">
                <img src="58.png" align=top>
            </a>
            <a href="08.txt" target="_blank">
                <img src="54.png" align=top>
            </a>
            <a href="09.txt" target="_blank">
                <img src="56.png" align=top>
            </a>
        </center>
        <p>
            <b>Примітка</b>
            . Для успішного виконання програми з останнього прикладу необхідно, щоб тека з програмою містила файл зображення:
        </p>
        <center>
            <img src="55.png" align=top>
        </center>
        <p>
            <b>Властивість anchor</b>
            <i>використовують для того, щоб вказати, чим є точка з вказаними координатами для створюваного об'єктами:</i>
        </p>
        <ul>
            <li>
            N — центр верхнього краю;</li>
            <li>
            S — центр нижнього краю;</li>
            <li>
            E — центр правого краю;</li>
            <li>
            W — центр лівого краю;</li>
            <li>
            NE — верхній правий кут;</li>
            <li>
            NW — верхній лівий  кут;</li>
            <li>
            SE — нижній правий кут;</li>
            <li>
            SW — нижній лівий  кут;</li>
            <li>
            CENTER — центр.</li>
        </ul>
        <p>



            Всі подані вище приклади (для скорочення коду) подано без використання ідентифікаторів чи тегів, які буде використано у прикладах, поданих нижче.
            <br>
            <br>

            <b>Метод focus_set</b>
            <i>використовують для фокусування уваги на полотні</i>
            , щоб мати можливість прив'язати події до виконання методів полотна.
            <br>
            <br>

            <b>Метод create_*</b>
            <i>використовують для створення об'єкта, де замість * пишуть тип об'єкта, вказуючи у дужках спочатку обов'язкові значення властивостей-координат, а потім — решти властивостей</i>
            <br>
            <br>


            Щоб зрозуміти написане, див. 
            <a href="01.txt" target="_blank">приклад</a>
            , у якому круг жовтого кольору зсувають на 2 пікселі, натискаючи на клавіатурі відповідні клавіші зі стрілками. У цьому прикладі звертення до об'єкту (круга) здійснено через ідентифікатор (ball).
            <br>
            <br>

            <b>Метод coords</b>
            <i>встановлює значення координат. Якщо вказано лише ідентифікатор або тег, то метод повертає поточні значення координат.</i>
            <br>
            <br>

            <b>Метод itemconfig</b>
            <i>встановлює значення властивостей, що не є координатами.</i>
            <br>
            <br>


            Щоб краще зрозуміти написане, див. 
            <a href="02.txt" target="_blank">приклад</a>
            , у якому при отриманні фокусу (натискати клавішу 
            <i>Tab</i>
            ) буде змінено розмір і колір квадрата.
            <br>
            <br>

            <b>Метод tag_bind</b>
            <i>надає можливість прив'язати опрацювання події до певної фігури на полотні, заданої ідентифікатором або тегом.</i>
            <br>
            <br>

            <b>Метод delete</b>
            <i>видаляє об'єкт. Якщо потрібно озвільнити все полотно, то замість ідентифікаторів або тегів використовують сталу ALL</i>
            <br>
            <br>


             — див. 
            <a href="03.txt" target="_blank">приклад</a>
            , де перетворення зображення на текст спричинено натисканням лівої кнопки миші.
        </p>
        <center>
            <video width="308" controls="" loop='true' autoplay='true'>
                <source src="48.mp4" type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
            </video>
        </center>
        <p>


            Наступний  
            <a href="04.txt" target="_blank">приклад</a>
             показує, як можна відобразити рух об'єкта (жовтий круг)
        <center>
            <video width="208" controls="" loop='true' autoplay='true'>
                <source src="49.mp4" type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
            </video>
        </center>
        <p>

            <b>Метод find_overlapping</b>
            <i>повертає назви усіх об'єктів, що мають непорожній перетин з прямокутником, заданим координатами протилежних вершинних</i>
            . Наприклад, така програма:
        </p>
        <tt>
            <pre>
            from tkinter import *
            root = Tk()
            c = Canvas(root, width=105, height=45, bg='white')
            c.pack()
            c11=c.create_rectangle(( 5, 5), (20, 20))
            c12=c.create_rectangle((25, 5), (40, 20)) 
            c13=c.create_rectangle((45, 5), (60, 20))
            c14=c.create_rectangle((65, 5), (80, 20), fill="green", tag="c14" )
            c15=c.create_rectangle((85, 5),(100, 20), fill="green")
            c21=c.create_rectangle(( 5,25), (20, 40))
            c22=c.create_rectangle((25,25), (40, 40)) 
            c23=c.create_rectangle((45,25), (60, 40))
            c24=c.create_rectangle((65,25), (80, 40), fill="green")
            c25=c.create_rectangle((85,25),(100, 40), fill="green")
            c00=c.create_rectangle((73,15), (93, 30), fill="yellow")
            print(c11, c12, c13, c14, c15)
            print(c21, c22, c23, c24, c25)
            print(c00)
            t=c.find_overlapping(73,15,93,30)
            print(t);
            root.mainloop()</pre>
        </tt>
        <p>
        створює таке вікно:</p>
        <center>
            <img src="57.png">
        </center>
        <p>
        і має таке консольне виведення:</p>
        <tt>
            <pre>
            1 2 3 4 5
            6 7 8 9 10
            11
            (4, 5, 9, 10, 11)
            </pre>
        </tt>
        <p>

            У цьому прикладі 5 зафарбованих прямокутників (4, 5, 9, 10, 11) мають точки, що належать до жовтого прямокутника (11).
            <br>
            <br>

            <a name="packs"></a>
            <font size=+3>
                <b>9. Розташування елементів за допомогою пакувальників</b>
            </font>
            <br>
            <br>

            <b>Пакувальник</b>
             (менеджер геометрії, менеджер розташування) — 
            <i>механізм розташування (пакування) елементів керування (віджетів) на вікні.</i>
            <br>
            <br>


            У бібліотеці tkinter є три пакувальники: 
            <i> pack, place, grid.</i>
             Зауважте: 
            <i>в одному віджеті можна використовувати лише один тип пакування.</i>
             При змішуванні різних типів пакування програма, швидше за все, не буде працювати. Розглянемо кожен з них окремо.
        </p>
        <ul>
            <li>
                <p>
                    <a name="pack"></a>
                    <b>pack</b>
                     — самий інтелектуальний (і непередбачуваний) з наявних пакувальників. При використанні цього пакувальника за допомогою властивості side потрібно вказати: до якої сторони батьківського віджета він має примикати. Як правило цей пакувальник використовують для розташування віджетів один за одним (зліва направо або зверху донизу) — див. приклад:
                </p>
                <tt>
                    <pre>
                    from tkinter import *
                    root = Tk ()
                    button1 = Button (text = "1")
                    button2 = Button (text = "2")
                    button3 = Button (text = "3")
                    button4 = Button (text = "4")
                    button5 = Button (text = "5")
                    button1.pack (side = 'left')
                    button2.pack (side = 'top')
                    button3.pack (side = 'left')
                    button4.pack (side = 'bottom')
                    button5.pack (side = 'right')
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="22.png">
                </center>
                <p>


                    Для створення складної структури з використанням цього пакувальника зазвичай використовують віджети Frame, вкладені один в один.
                    <br>
                    <br>

                    <b>Аргументи pack:</b>
                </p>
                <ul>
                    <li>
                        <p>
                            <b>side</b>
                             ("left" / "right" / "top" / "bottom")  — до якої сторони має примикати віджет;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>fill</b>
                             (None / "x" / "y" / "both") — чи розширювати простір, що надають віджету;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>expand</b>
                             (True / False) — чи розширювати сам віджет, щоб він зайняв весь наданий йому простір;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>in_</b>
                              — явна вказівка на те, в якій батьківський віджет потрібно вкласти даний віджет.
                        </p>
                    </li>
                </ul>
                <p>

                    <b>Додаткові методи віджетів для роботи з пакувальником pack:</b>
                </p>
                <ul>
                    <li>
                        <b>pack_configure</b>
                         — синонім для pack;</p>
                    </li>
                    <li>
                        <p>
                            <b>pack_slaves</b>
                             (синонім slaves) — повертає список всіх дочірніх запакованих віджетів;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>pack_info</b>
                             — повертає інформацію про конфігурацію пакування;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>pack_propagate</b>
                             (синонім propagate) (True / False) — включає / відключає поширення інформації про геометрію дочірніх віджетів. Як усталено віджет змінює свій розмір відповідно до розміру своїх нащадків. Цей метод може відключити таку поведінку — pack_propagate(False). Це може бути корисно, якщо необхідно, щоб віджет мав фіксований розмір і не змінював його за примхою нащадків;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>pack_forget</b>
                             (синонім forget) — видаляє віджет і всю інформацію про його розташування з пакувальника. Пізніше цей віджет може бути знову розміщений.
                        </p>
                    </li>
                </ul>
            </li>
            <li>
                <p>

                    <a name="grid"></a>
                    <b>grid</b>
                     — 
                    <i>розташовує віджет у комірку прямокутної таблиці.</i>
                    <br>
                    <br>

                    <b>Аргументи grid:</b>
                </p>
                <ul>
                    <li>
                        <p>
                            <b>row</b>
                             — номер рядка, в який буде вкладено віджет;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>rowspan</b>
                             — кількість рядків, які займає віджет (для того випадку, коли висоти одного рядка не вистачає);
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>column</b>
                             — номер стовпчика, в який буде вкладено віджет;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>columnspan</b>
                             — кількість стовпчиків, які займає віджет (для того випадку, коли ширини одного стовпчика не вистачає);
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>padx / pady</b>
                             — розмір зовнішньої межі (бордюру) по горизонталі / вертикалі;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>ipadx / ipady</b>
                             — розмір внутрішньої межі (бордюру) по горизонталі і вертикалі. Різниця між pad і ipad у тому, що при вказівці pad розширюється вільний простір, а при ipad розширюється віджет;
                        </p>
                    </li>
                    <li>
                        <b>sticky</b>
                         ("n", "s", "e", "w" або їхня комбінація) — вказує, до якої межі «приклеювати» віджет. Дозволяє розширювати віджет у вказаному напрямку. Межі названо відповідно до сторін світу:
                        <ul>
                            <li>
                            "n" (північ) — верхня межа;</li>
                            <li>
                            "s" (південь) — нижня;</li>
                            <li>
                            "w" (захід) — ліва;</li>
                            <li>
                            "e" (схід) — права.</li>
                        </ul>
                    </li>
                    <li>
                        <p>
                            <b>in_</b>
                             — явна вказівка на те, в якій батьківський віджет потрібно розташувати даний віджет.
                        </p>
                    </li>
                </ul>
                <p>

                Приклади використання:</p>
                <tt>
                    <pre>
                    entry1.grid  (row = 0, column = 0, columnspan = 3)
                    button1.grid (row = 1, column = 0)
                    button2.grid (row = 1, column = 1)
                    button3.grid (row = 1, column = 2)</pre>
                </tt>
                <p>

                    <b>Додаткові методи віджетів для роботи з пакувальником grid:</b>
                </p>
                <ul>
                    <li>
                        <b>grid_configure</b>
                         — синонім для grid;</p>
                    </li>
                    <li>
                        <p>
                            <b>grid_slaves</b>
                             (синонім slaves) — повертає список всіх дочірніх запакованих віджетів;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>grid_info</b>
                             — повертає інформацію про конфігурацію пакування;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>grid_propagate</b>
                             (синонім propagate) — (True / False) — включає / відключає поширення інформації про геометрію дочірніх віджетів. Як усталено віджет змінює свій розмір відповідно до розміру своїх нащадків. Цей метод може відключити таку поведінку — pack_propagate(False). Це може бути корисно, якщо необхідно, щоб віджет мав фіксований розмір і не змінював його за примхою нащадків;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>grid_forget</b>
                             (синонім forget) — видаляє віджет і всю інформацію про його розташування з пакувальника. Пізніше цей віджет може бути знову розміщений.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>grid_remove</b>
                             — видаляє віджет з-під керування пакувальником, але зберігає інформацію про пакування. Цей метод зручно використовувати для тимчасового видалення віджета.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>grid_bbox</b>
                             (синонім bbox) — повертає координати (у пікселях) зазначених стовпців і рядків.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>grid_location</b>
                             (синонім location) — приймає два аргументи-координати: 
                            <i>x</i>
                             і 
                            <i>y</i>
                             (у пікселях). Повертає номер рядка і стовпця, в які потрапляє точка із зазначеними координатами, або -1, якщо точка поза віджетом.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>grid_size</b>
                             (синонім size) — повертає розмір таблиці в рядках і стовпцях.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>grid_columnconfigure</b>
                             (синонім columnconfigure) / grid_rowconfigure (синонім rowconfigure) — функції для конфігурування пакувальника. Методи приймають номер рядка / стовпчика і аргументи конфігурації. Список можливих аргументів такий:
                        </p>
                        <ul>
                            <li>
                                <p>
                                    <b>minsize</b>
                                     — мінімальна ширина / висота рядка / стовпчика;
                                </p>
                            </li>
                            <li>
                                <p>
                                    <b>weight</b>
                                     — «вага» рядка / стовпчика при збільшенні розміру віджета. 0 означає, що рядок / стовпчик не буде розширено. Рядок / стовпчик з "вагою" 
                                    <i>k</i>
                                     буде розширено у 
                                    <i>k</i>
                                     разів швидше, ніж з вагою 1;
                                </p>
                            </li>
                            <li>
                                <p>
                                    <b>uniform</b>
                                     — об'єднання рядків / стовпчиків у групи. Рядки / стовпчики, що мають однаковий параметр uniform, буде розширено строго у відповідності зі своїм вагою;
                                </p>
                            </li>
                            <li>
                                <p>
                                    <b>pad</b>
                                     — розмір межі (бордюру) — вказує на те, скільки простору буде додано до найбільшого віджету в рядку / стовпчику.
                                </p>
                            </li>
                        </ul>
                    </li>
                </ul>
                <p>

                Приклад — текстовий віджет з двома смугами прокрутки:</p>
                <tt>
                    <pre>
                    from tkinter import *
                    root = Tk ()
                    text = Text (wrap = NONE)
                    vscrollbar = Scrollbar (orient = 'vert', command = text.yview)
                    text [ 'yscrollcommand'] = vscrollbar.set
                    hscrollbar = Scrollbar (orient = 'hor', command = text.xview)
                    text [ 'xscrollcommand'] = hscrollbar.set

                    # Розташовуємо віджети
                    text.grid (row = 0, column = 0, sticky = 'nsew')
                    vscrollbar.grid (row = 0, column = 1, sticky = 'ns')
                    hscrollbar.grid (row = 1, column = 0, sticky = 'ew')

                    # Конфігуруємо пакувальник, щоб текстовий віджет розширювався
                    root.rowconfigure (0, weight = 1)
                    root.columnconfigure (0, weight = 1)
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="23.png">
                </center>
            </li>
            <li>
                <p>

                    <a name="place"></a>
                    <b>place</b>
                     — </i>
                    розміщує віджет у фіксованому місці з фіксованим розміром.</i>
                     Також дозволяє вказувати координати розташування у відносних одиницях для реалізації «гумового» розміщення. При використанні цього пакувальника необхідно вказувати координати кожного віджета.
                    <br>
                    <br>

                    <b>Аргументи place</b>
                </p>
                <ul>
                    <li>
                        <p>
                            <b>anchor</b>
                             (зі значеннями "n", "s", "e", "w", "ne", "nw", "se", "sw" або "center") — вказівка на те, який кут або яку сторону віджета буде вказано в аргументах x, y, relx, rely. Як усталено "nw" — лівий верхній кут;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>bordermode</b>
                             (зі значеннями "inside", "outside", "ignore") — визначає, в якій мірі буде враховано межі при розміщенні віджета;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>in_</b>
                             — явна вказівка на те, в який батьківський віджет буде вкладено даний;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>x</b>
                             і 
                            <b>y</b>
                             — абсолютні координати (у пікселях) розташування віджету;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>width</b>
                             і 
                            <b>height</b>
                             — абсолютні ширина і висота віджету;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>relx</b>
                             і 
                            <b>rely</b>
                             — відносні координати (від 0.0 до 1.0) розташування віджета;
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>relwidth</b>
                             і 
                            <b>relheight</b>
                             — відносні ширина і висота віджету.
                        </p>
                    </li>
                </ul>
                <p>

                    <b>Додаткові методи віджетів для роботи з пакувальником place:</b>
                    <br>
                    <i>place_slaves, place_forget, place_info</i>
                     — див. опис аналогічних методів пакувальника pack.
                </p>
            </li>
        </ul>
        <p>

            <a name="events"></a>
            <font size=+3>
                <b>10. Опрацювання подій</b>
            </font>
            <br>
            <br>

            Властивість command віджетів Button, Checkbutton, Radiobutton, Spinbox, Scrollbar, Scale можна прив'язати до події. Вище вже було використано цей спосіб у прикладі з натисканням лівої кнопки миші на зображенні кнопки
        </p>
        <tt>
            <pre>
            button2 = Button (root, bg="red", text="Натисни мене!", command=button_clicked)</pre>
        </tt>
        <p>

            Такий спосіб вважають найкращим і найзручнішим способом прив'язування до події.
            <br>
            <br>

            <a name="bind"></a>
            <b>bind</b>
             — 
            <i>метод пов'язування елемента керування, події і функції (обробника події)</i>
             такою вказівкою:
            <br>
            <br>
            <tt>
                <i>назва_віджета</i>
                .bind(
                <i>назва_події</i>
                , 
                <i>назва_функції</i>
                )
                <br>
                <br>
            </tt>

            Третім 
            <i>необов'язковим</i>
             аргументом методу bind може бути  рядок "+", якщо прив'язування додають до вже наявних. Інакше (якщо цей третій аргумент опущено або він є порожнім рядком) прив'язування заміщає всі інші прив'язування даної події до віджету.
            <br>
            <br>


            Метод bind повертає ідентифікатор прив'язування, який можна використати у методу unbind з протилежним призначенням відв'язування. Зауважте: якщо bind прив'язано до вікна верхнього рівня, то tkinter буде опрацьовувати події всіх віджетів цього вікна (див. bind_all нижче). Функція, яку буде викликано при настанні події, повинна приймати один аргумент. Це об'єкт класу Event, що має такі властивості (в дужках вказані події, для яких цю властивість встановлено):
        </p>
        <ul>
            <li>
                <p>
                    <b>serial</b>
                     — серійний номер події (всі події);
                </p>
            </li>
            <li>
                <p>
                    <b>num</b>
                     — номер кнопки миші (ButtonPress, ButtonRelease);
                </p>
            </li>
            <li>
                <p>
                    <b>focus</b>
                     — чи має вікно фокус (Enter, Leave);
                </p>
            </li>
            <li>
                <p>
                    <b>height</b>
                     і 
                    <b>width</b>
                     — ширина й висота вікна (Configure, Expose);
                </p>
            </li>
            <li>
                <p>
                    <b>keycode</b>
                     — код натиснутої клавіші (KeyPress, KeyRelease);
                </p>
            </li>
            <li>
                <p>
                    <b>state</b>
                     — стан події (для ButtonPress, ButtonRelease, Enter, KeyPress, КeyRelease, Leave, Motion — у вигляді числа, для Visibility — у вигляді рядка);
                </p>
            </li>
            <li>
                <p>
                    <b>time</b>
                     — час настання події (всі події);
                </p>
            </li>
            <li>
                <p>
                    <b>x</b>
                     і 
                    <b>y</b>
                     — координати вказівника миші на віджеті;
                </p>
            </li>
            <li>
                <p>
                    <b>x_root</b>
                     і 
                    <b>y_root</b>
                     — координати вказівника миші на екрані (ButtonPress, ButtonRelease, KeyPress, KeyRelease, Motion);
                </p>
            </li>
            <li>
                <p>
                    <b>char</b>
                     — набраний на клавіатурі символ (KeyPress, KeyRelease);
                </p>
            </li>
            <li>
                <p>
                    <b>send_event</b>
                     — див. документацію до X / Windows;
                </p>
            </li>
            <li>
                <p>
                    <b>keysym</b>
                     — набраний на клавіатурі символ (KeyPress, KeyRelease);
                </p>
            </li>
            <li>
                <p>
                    <b>keysym_num</b>
                     — код набраного на клавіатурі символу (KeyPress, KeyRelease);
                </p>
            </li>
            <li>
                <p>
                    <b>type</b>
                     — тип події у вигляді числа (всі події);
                </p>
            </li>
            <li>
                <p>
                    <b>widget</b>
                     — віджет, який отримав подія (всі події);
                </p>
            </li>
            <li>
                <p>
                    <b>delta</b>
                     — зміна при обертанні колеса миші (MouseWheel).
                </p>
            </li>
        </ul>
        <p>


            Метод bind може повертати рядки "continue" і "break". Якщо функція повертає "continue" то tkinter продовжить опрацювання інших прив'язок події, якщо "break" — опрацювання цієї події буде припинено. Якщо метод нічого не повертає (якщо повернуто None), то опрацювання подій триває. Інакше кажучи, це еквівалентно поверненню "continue".
            <br>
            <br>

            <a name="nameform"></a>
            <b>Форми назв подій</b>
        </p>
        <ul>
            <li>
                <p>

                    <b>
                        <tt>
                            <i>
                                <a href="http://www.tcl.tk/man/tcl8.5/TkCmd/keysyms.htm" target="_blank">Символ_клавіатури</a>
                            </i>
                        </tt>
                    </b>
                    . Приклад для події натискання клавіші клавіатури:
                    <br>
                    <br>
                    <tt>
                        <i>назва_віджету</i>
                        .bind("z", callback)
                        <br>
                        <br>
                    </tt>


                    Метод (функцію) callback буде викликано кожного разу, коли буде натиснуто клавішу 
                    <i>z</i>
                    .
                </p>
            </li>
            <li>
                <p>

                    <b>
                        <tt>
                            &lt;
                            <i>Modifier-modifier-type-detail</i>
                            &gt;
                        </tt>
                    </b>
                    . Тут назву події записано в кутові дужки. Всередині є нуль або більше модифікаторів, тип події та додаткова інформація (номер натиснутої клавіші миші або символ клавіатури). Поля розділяються дефісом або пробілом — див. приклад прив'язування одночасного натискання клавіш 
                    <i>Ctrl + Shift + q</i>
                    .
                    <br>
                    <br>
                    <tt>
                        <i>назва_віджету</i>
                        .bind ("&lt;Control-Shift-KeyPress-q&gt;", callback)
                        <br>
                        <br>
                    </tt>

                    У цьому прикладі KeyPress можна прибрати. Можливі модифікатори такі — через тире вказано усталену назву відповідної клавіші, якщо вона відмінна від назви модифікатора:
                </p>
                <ul>
                    <li>
                    Return — Enter;</li>
                    <li>
                    Escape — Esc;</li>
                    <li>
                    Control — Ctrl;</li>
                    <li>
                    Alt;</li>
                    <li>
                    Shift;</li>
                    <li>
                    Lock;</li>
                    <li>
                    Extended;</li>
                    <li>
                    Prior — PgUp;</li>
                    <li>
                    Next — PgDown;</li>
                    <li>
                    Button-1 або 1 — натиснута перша (ліва) кнопка миші;</li>
                    <li>
                    Button-2 або 2 — натиснута друга (середня) кнопка миші;</li>
                    <li>
                    Button-3 або 3 — натиснута третя (права) кнопка миші;</li>
                    <li>
                    Button-4 — натиснута четверта кнопка;</li>
                    <li>
                    Button-5 — натиснута п'ята кнопка;</li>
                    <li>
                    Mod1, M1, Command;</li>
                    <li>
                    Mod2, M2, Option;</li>
                    <li>
                    Mod3, M3;</li>
                    <li>
                    Mod4, M4;</li>
                    <li>
                    Mod5, M5;</li>
                    <li>
                    Meta, M;</li>
                    <li>

                        Double — подвійне клацання миші (наприклад, 
                        <Double-Button-1>);
                    </li>
                    <li>
                    Triple — потрійне клацання миші;</li>
                    <li>
                    Quadruple — чотирикратне клацання миші.</li>
                </ul>
            </li>
            <li>
                <p>

                    <b>
                        <tt>
                            &lt;&lt;
                            <i>Нова_назва_події</i>
                            &gt;&gt;
                        </tt>
                    </b>
                     Цей спосіб дозволяє прив'язувати віртуальні події, породжені самим застосунком. Назви таких подій записують у подвійних кутових дужках.
                </p>
            </li>
        </ul>
        <p>

        Приклади назв подій:</p>
        <ul>
            <li>
                <tt>&lt;Button-1&gt;</tt>
                 — натиснуто ліву клавішу миші;
            </li>
            <li>
                <tt>&lt;Alt-Motion&gt;</tt>
                 — рух миші з натиснутою на клавіатурі клавішею 
                <i>Alt;</i>
            </li>
            <li>
                <tt>&lt;Key&gt;</tt>
                 — натискання будь-якої клавіші на клавіатурі.
            </li>
        </ul>
        <p>

        Приклад програми — дві різні подіїї зі своїми розробниками пов'язано з одним елементом керування:</p>
        </tt>
        <pre>
        from tkinter import *
        root=Tk()
        def leftclick(event):
            print ('Натисли ліву кнопку миші.')
        def rightclick(event):
            print('Натисли праву кнопку миші.')
        button1=Button(root, text='Натискайте!')
        button1.pack()
        button1.bind('&lt;Button-1&gt;', leftclick)
        button1.bind('&lt;Button-3&gt;', rightclick)
        root.mainloop()
        </pre>
        </tt>
        <center>
            <img src="24.png">
        </center>
        <p>


            Обробник події, який викликають за допомогою метода bind, має обов'язковий параметр, через який передають назву події. Зазвичай його записують як event, хоча він може мати іншу назву 
            <i>в описі</i>
             обробника. Його обов'язково записують на першому місці в описі функції і другим в описі методу (див. приклад).
        </p>
        <tt>
            <pre>

                from tkinter import *
                root = Tk()
                class myButton:
                  def __init__(self):      # Конструктор
                    self.b = Button(text='Натискайте!', width=9, height=1)
                    self.b.bind('
                <Button-1>', self.change)
                    self.b.pack()
                  def change(self, event): # Метод опрацювання події натискання лівої кнопки миші 
                    self.b['fg'] = "green"
                    self.b['activeforeground'] = "red"
                myButton()
                root.mainloop()
            </pre>
        </tt>
        <center>
            <img src="60.png">
            <img src="61.png">
            <img src="62.png">
            <img src="63.png">
        </center>
        <p>

            <a name="pass"></a>
            <b>Передавання додаткового аргумента обробника функції у метод bind</b>
             здійснюють за допомогою лямбда-функції — див. приклад коду з передаванням кольору напису.
        </p>
        <tt>
            <pre>
            from tkinter import *
            root = Tk()
            def f(e, c): l['fg'] = c
            l = Label(text="Натискайте кнопки миші!")
            l.bind('&lt;Button-1&gt;', lambda e, c="red":   f(e, c))  # для лівої  кнопки миші
            l.bind('&lt;Button-3&gt;', lambda e, c="green": f(e, c))  # для правої кнопки миші
            l.pack()
            root.mainloop()</pre>
        </tt>
        <center>
            <img src="64.png">
            <img src="65.png">
            <img src="66.png">
        </center>
        <p>


            Таким чином, один і той самий обробник подій використано для різних подій, але з різними значеннями параметра обробника. Інакше потрібно створювати окремий обробник для кожної події.
            <br>
            <br>


            Цей спосіб можна застосувати і до властивості command, якщо така є в елемента керування. В останньому випадку параметр назви події (зазвичай event) зайвий, бо обробляють лише одну подію клацання лівою кнопкою миші.
            <br>
            <br>

            <a name="eventstypes"></a>
            <b>Вбудовані події</b>
        </p>
        <ul>
            <li>
                <p>
                    <b>Activate, Deactivate</b>
                    . Ці дві події буде надіслано до кожного підвікна вікна верхнього рівня, коли буде змінено його стан. Подію Activate буде надіслано при активуванні вікна. Аналогічно, подію Deactive буде надіслано, коли вікно стане неактивним.
                </p>
            </li>
            <li>
                <p>

                    <b>ButtonPress, ButtonRelease, Motion</b>
                    . Події виникають відповідно при натисканні, відпусканні кнопки миші або переміщенні вказівника миші. Повідомлення про події, як правило, буде надіслано до вікна, що містить вказівник. При натиснутій кнопці миші вікно, що містить вказівник миші, автоматично отримує тимчасове захоплення вказівника. Повідомлення про ці події будуть надіслані й у це вікно, незалежно від того, яке вікно містить вказівник, поки всі кнопки не будуть відпущені.
                </p>
            </li>
            <li>
                <p>

                    <b>Colormap</b>
                    . Подія виникає при зміні, встановленні чи деісталяції кольорової мапи.
                </p>
            </li>
            <li>
                <p>

                    <b>Configure</b>
                    . Подію буде надіслано до вікна щойно буде змінено його розмір, розташування або ширину межі, а іноді — при зміні позиції у порядку набору.
                </p>
            </li>
            <li>
                <p>

                    <b>Destroy</b>
                    . Про цю подію буде повідомлено вікно після дій щодо його знищення. При повідомленні віджет перебуватиме у напівмертвому стані: все ще існує, але більшість операцій з ним нездійснена.
                </p>
            </li>
            <li>
                <p>

                    <b>Enter, Leave</b>
                    . Події виникають відповідно входженні у вікно і виході з нього вказівника миші.
                </p>
            </li>
            <li>
                <p>

                    <b>Expose</b>
                    . Подія виникає, коли все вікно або його частину потрібно перемалювати. Зазвичай клієнтським застосункам не потрібно обробляти подію Expose, бо  Tk опрацьовує їх внутрішньо.
                </p>
            </li>
            <li>
                <p>

                    <b>FocusIn, FocusOut</b>
                    . Події виникають при зміні фокусу клавіатури. Повідомлення про FocusOut буде надіслано до вікна, що втрачає фокус, а про FocusIn — тому, що набуває.
                </p>
            </li>
            <li>
                <p>

                    <b>Gravity, Reparent, Circulate</b>
                    . Повідомлення про події Gravity і Reparent, як правило, не доходять до застосунків Tk. Їх включено у цей список для повноти. Подія Circulate вказує на те, що вікно переміщено до верхньої або нижньої частини порядку накладення в результаті запиту протоколу XCirculateSubwindows. Порядок складування може змінитися з інших причин, які не породжують подію Circulate. Tk не використовує XCirculateSubwindows внутрішньо. Цей тип події включено лише для повноти опису. Немає надійного способу відстежувати зміни позиції вікна у порядку складування.
                </p>
            </li>
            <li>
                <p>

                    <b>KeyPress, KeyRelease</b>
                    . Події виникають відповідно при натисканні й відпусканні клавіші. Повідомлення про них буде надіслано до вікна з фокусом на клавіатурі.
                </p>
            </li>
            <li>
                <p>

                    <b>Map, Unmap</b>
                    . Події створюються щоразу, коли змінюється стан відображення вікна.
                </p>
            </li>
            <li>
                <p>

                    <b>MapRequest, CirculateRequest, ResizeRequest, ConfigureRequest, Create</b>
                    . Про ці події, як правило, не повідомляють застосунки Tk. Їх включено у перелік для повноти, щоб дозволити писати менеджери вікон X11 в Tk. Про ці події повідомляють лише тоді, коли клієнт вибрав SubstructureRedirectMask, а ядро Tk не використовує цю маску.
                </p>
            </li>
            <li>
                <p>

                    <b>MouseWheel</b>
                    . Подія виникає при прокручуванні коліщатка миші. Подію завжди буде спрямовано до вікна з фокусом. Після отримання події, можна використати заміну %D, щоб отримати поле delta для події з цілим числом, що описує рух коліщатка миші. Найменше значення, про яке система буде повідомляти, визначено ОС. Знак значення визначає, в якому напрямку прокручувати віджет: додатні значення — прокручування вгору, від'ємні — вниз.
                </p>
            </li>
            <li>
                <p>

                    <b>Property</b>
                    . Подія виникає при зміні чи вилученні властивості  (вікна). Повідомлення про цю подію, як правило, не доходить до Tk застосунків, бо їх  опрацьовує ядро Tk.
                </p>
            </li>
            <li>
                <p>

                    <b>Visibility</b>
                    . Подія виникає, коли вікно буде перекрито іншим вікном, розташованим над ним (у порядку складування). Поле стану %s описує (новий) стан.
                </p>
            </li>
        </ul>
        <p>

            <a name="bind_add"></a>
            <b>Додаткові методи *bind*</b>
        </p>
        <ul>
            <li>
                <p>
                    <b>bind_all</b>
                     — прив'язування для всіх віджетів програми. На відміну від прив'язування до вікна верхнього рівня, цей метод прив'язує всі віджети застосунку, який може мати й кілька вікон;
                </p>
            </li>
            <li>
                <p>
                    <b>bind_class</b>
                     — прив'язування для всіх віджетів даного класу — див. приклад.
                </p>
                <tt>
                    <pre>
                    from tkinter import *
                    def callback (e):
                        print('Натиснуто кнопку ', e.widget['text'])
                    root = Tk ()
                    button1 = Button (root, text = '1')
                    button1.pack ()
                    button2 = Button (root, text = '2')
                    button2.pack ()
                    root.bind_class ('Button', '&lt;1&gt;', callback)
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="25.png">
                </center>
            </li>
            <li>
                <p>

                    <b>bindtags</b>
                     — змінює порядок опрацювання прив'язок. Стандартний порядок такий:
                </p>
                <ul>
                    <li>
                    прив'язане до віджету (bind);</li>
                    <li>
                    прив'язане до класу (bind_class);</li>
                    <li>
                    прив'язане до вікна (root.bind);</li>
                    <li>
                    прив'язане до всіх віджетів (bind_all).</li>
                </ul>
                <p>
                Приклад зміни порядку опрацювання на зворотний:</p>
                <tt>
                    <pre>
                    from tkinter import *
                    def callback1 (e): print('callback1')
                    def callback2 (e): print('callback2')
                    def callback3 (e): print('callback3')
                    def callback4 (e): print('callback4')
                    root = Tk ()
                    button = Button (root)
                    button.pack ()
                    button.bind ('&lt;1&gt;', callback1)
                    root.bind_class ('Button', '&lt;1&gt;', callback2)
                    root.bind ('&lt;1&gt;', callback3)
                    root.bind_all ('&lt;1&gt;', callback4)
                    button.bindtags (('all', root, 'Button', button))
                    root.mainloop ()</pre>
                </tt>
                <center>
                    <img src="26.png">
                </center>
            </li>
            <li>
                <p>

                    <b>unbind</b>
                     — відв'язування віджету від події з аргументом — ідентифікатором, отриманим від методу bind.
                </p>
            </li>
            <li>
                <p>
                    <b>unbind_all</b>
                     — те саме, що й unbind, але для методу bind_all.
                </p>
            </li>
            <li>
                <p>
                    <b>unbind_class</b>
                     — те саме, що й unbind, але для методу bind_class.
                </p>
            </li>
        </ul>
        <p>

            <a name="image"></a>
            <font size=+3>
                <b>11. Зображення</b>
            </font>
            <br>
            <br>

            Для роботи із зображеннями у бібліотеці Tkinter є два класи:
        </p>
        <ul>
            <li>
            BitmapImage — двоколірне зображення;</li>
            <li>
            PhotoImage — багатоколірне зображення.</li>
        </ul>

        <b>Аргументи конструктора класу BitmapImage:</b>
        </p>
        <ul>
            <li>
                <b>background</b>
                 — колір тла (зазвичай чорний);
            </li>
            <li>
                <b>foreground</b>
                 — колір переднього плану (зазвичай білий);
            </li>
            <li>
                <b>file</b>
                 — шлях до файлу із зображенням;
            </li>
            <li>
                <b>maskfile</b>
                 — шлях до маски (вказує, які пікселі будуть прозорими);
            </li>
            <li>
                <b>data</b>
                 — завантажені у пам'ять дані зображення;
            </li>
            <li>
                <b>maskdata</b>
                 — завантажені в пам'ять дані маски.
            </li>
        </ul>
        <p> 
        Приклад:</p>
        <tt>
            <pre>
            from tkinter import *
            data = '''#define image_width  15
                      #define image_height 15
            static unsigned char image_bits[] = {
               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x1c, 0x30, 0x0c, 0x60, 0x06,
               0x60, 0x06, 0xc0, 0x03, 0xc0, 0x03, 0x60, 0x06, 0x60, 0x06, 0x30, 0x0c,
               0x38, 0x1c, 0x00, 0x00, 0x00, 0x00 };'''
            root=Tk()
            image = BitmapImage(data=data, background='blue', foreground='yellow')
            button=Button(root, image=image)
            button.pack()
            root.mainloop()</pre>
        </tt>
        <center>
            <img src="27.png">
        </center>
        <p>

            <b>PhotoImage</b>
             дає можливість використовувати багатоколірне зображення. Клас має кілька (досить примітивних) методів для роботи з зображеннями. PhotoImage гарантовано розуміє формат GIF.
            <br>
            <br>

            <b>Аргументи конструктора класу PhotoImage:</b>
        </p>
        <ul>
            <li>
                <b>file</b>
                 — шлях до файлу з зображенням;
            </li>
            <li>
                <b>data</b>
                 — завантажені у пам'ять дані зображення;
            </li>
            <li>
                <b>format</b>
                 — формат зображення;
            </li>
            <li>
                <b>width, height</b>
                 — ширина й висота зображення;
            </li>
            <li>
                <b>gamma</b>
                 — корекція гами;
            </li>
            <li>
                <b>palette</b>
                 — палітра зображення.
            </li>
        </ul>
        <p>

            <a name="dialog"></a>
            <font size=+3>
                <b>12. Вікна діалогу</b>
            </font>
            <br>
            <br>


            Пакет tkinter містить кілька модулів доступу до вікон діалогу. Ці модулі необхідно імпортувати окремо. У поданих нижче прикладах для messagebox (потрібно використовувати лише один із запропонованих способів) у коментарі з поясненно синтаксису виклику.
        </p>
        <tt>
            <pre>
            import tkinter.messagebox            # tkinter.messagebox.askyesno()
            from tkinter.messagebox import *     # askyesno()
            from tkinter import messagebox       # messagebox.askyesno()
            from tkinter import messagebox as my # замість my може бути довільна назва my.askyesno()</pre>
        </tt>
        <p>

            <a name="messagebox"></a>
            <b>messagebox</b>
             — 
            <i>модуль доступу до вікон діалогу з вибором одного з 2−3 варіантів («Так», «Ні», «Скасувати») або інформаційного вікна з повідомленням.</i>
            <br>
            <br>


            askyesno — стандартне вікно діалогу модуля messagebox для вибору одного з 2 варіантів: «Yes» або «No» («Так» або «Ні») — див. приклад.
        </p>
        <tt>
            <pre>
            from tkinter import *
            from tkinter.messagebox import * 
            def f():
              if (askyesno (title="Запит", message="Перенести дані?")):
                l['text'] = e.get()
                e.delete(0, END)
            root = Tk()
            e = Entry()
            l = Label()
            b = Button(text = 'Переписати', command = f)
            e.pack()
            b.pack()
            l.pack()
            root.mainloop()</pre>
        </tt>
        <center>
            <img src="67.png">
            <br>
            <br>
            <img src="68.png">
            <br>
            <br>
            <img src="67.png">
            <br>
            <br>
            <img src="69.png">
            <br>
            <br>
            <img src="70.png">
        </center>
        <p>


            Натискання кнопки з написом «Yes» (Так) вікна діалогу повертає у програму значення True, «No» (Ні) — False (як і закриття вікна). Таким чином можна опрацювати вибір користувача. В даному випадку при його згоді дані буде переписано з поля над кнопкою у напис під кнопкою.
            <br>
            <br>


            Можна записати скорочено:
            <br>
            <br>
            <tt>

                askyesno ("Запит","Перенести дані?")
                <br>
                <br>
            </tt>


            Схожі породжують інші функції:
        </p>
        <center>

            askokcancel
            <br>
            <img src="71.png">
            <br>
            <br>

            askquestion
            <br>
            <img src="72.png">
            <br>
            <br>

            askretrycancel
            <br>
            <img src="73.png">
            <br>
            <br>

            askyesnocancel
            <br>
            <img src="74.png">
        </center>
        <p>

            Зображення вище створено при ОС Linux Mint 18 Mate. Останні три функції повертають не значення True чи False, а відповідні рядки написів на кнопках.
            <br>
            <br>


            Іншу групу модуля messagebox вікна складають інформаційні вікна лише з однією кнопкою, які слугують для виведення повідомлень. Це showerror, showinfo і showwarning — див. приклад.
        </p>
        <tt>
            <pre>
            from tkinter import *
            from tkinter.messagebox import * 
            def f():
              s = e.get()
              if s.isdigit():
                e.delete(0, END)
                l['text'] = s
              else:
                showerror("Помилка","Потрібно ввести десятковий запис числа!")
                showinfo("Повідомлення","Потрібно ввести десятковий запис числа!")
                showwarning("Зауваження","Потрібно ввести десятковий запис числа!")
            root = Tk()
            e = Entry()
            l = Label()
            b = Button(text = 'Переписати', command = f)
            e.pack()
            b.pack()
            l.pack()
            root.mainloop()</pre>
        </tt>
        <center>
            <img src="75.png">
            <br>
            <br>
            <img src="76.png">
            <br>
            <br>
            <img src="77.png">
            <br>
            <br>
            <img src="78.png">
        </center>
        <p>

            <a name="filedialog"></a>
            <b>filedialog</b>
             — 
            <i>модуль, що містить такі функції:</i>
        </p>
        <i>
            <ul>
                <li>
                askopenfilename — надає вікно діалогу для відкриття файлу;</li>
                <li>
                asksaveasfilename — надає вікно діалогу для збереження файлу.</li>
            </ul>
        </i>
        <p>

        Обидві функції повертають назву файлу, який потрібно відкрити або зберегти, але самі вони його не відкривають і не зберігають. Це роблять програмними засобами самого Python.</p>
        <tt>
            <pre>
            from tkinter import *
            from tkinter.filedialog import * 
            def inText():
              name = askopenfilename()
              if (str(name)!="()"):
                f = open(name)
                s = f.read()
                t.insert(1.0,s)
                f.close()
             
            def outText():
              name = asksaveasfilename(
                filetypes = (
                ("TXT files", "* .txt"),
                ("HTML files", "* .html; *. htm"),
                ( "All files", "*. *")))
              if (str(name)!=""):  
                f = open(name, 'w')
                s = t.get(1.0, END)
                f.write(s)
                f.close()
             
            root = Tk()
            t = Text(width = 30, height = 5)
            t.grid (columnspan = 2)
            b1 = Button(text = "Відкрити", command = inText)
            b2 = Button(text = "Зберегти", command = outText)
            b1.grid (row = 1, sticky = E)
            b2.grid (row = 1, column = 1, sticky = W)
            root.mainloop()</pre>
        </tt>
        <center>
            <img src="79.png">
            <br>
            <br>
            <img src="80.png">
            <br>
            <br>
            <img src="81.png">
            <br>
            <br>
            <img src="82.png">
        </center>
        <p>

            <b>Примітка</b>
            .
        </p>
        <ul>
            <li>
                <p>
                Перелік filetype містить назви типів файлів, які буде відкрито або збережено, та відповідні розширення. Останній малюнок ілюструє запис файла з назвою output.txt у теку /home/chief/.</p>
            </li>
            <li>
                <p>
                При розміщенні текстового поля методом grid не вказано аргументи row і column. У таких випадках буде використано значення нуль.</p>
            </li>
            <li>
                <p>

                    Умовні оператори:
                    <br>
                    <br>
                    <tt>

                        if (str(name)!="()"):
                        <br>

                        if (str(name)!=""):
                        <br>
                        <br>
                    </tt>

                    використано для того, щоб уникнути зауважень (помилок) при натисканні клавіш з написом 
                    <i>Cancel</i>
                    .
                </p>
            </li>
        </ul>
        <p>

            <a name="simpledialog"></a>
            <b>simpledialog</b>
             — 
            <i>модуль, що містить такі функції:</i>
        </p>
        <i>
            <ul>
                <li>
                askstring — надає вікно діалогу для введення рядка;</li>
                <li>
                askinteger — надає вікно діалогу для введення цілого значення;</li>
                <li>
                askfloat — надає вікно діалогу для введення запису десяткового дробу</li>
            </ul>
        </i>
        <p>
        — див приклад коду.</p>
        <tt>
            <pre>
            from tkinter import *
            from tkinter.simpledialog import *
            root = Tk()

            a = askstring("Введення даних", "Ваше ім'я?",parent=root)
            if (a!=None): print("Ваше ім'я ", a)
            else:         print("Ви не знаєте свого імені?")

            a = askinteger("Введення даних", "Скільки Вам повних років?",
                parent=root, minvalue=0, maxvalue=125)
            if (a!=None): print("Ваш вік (у роках) ", a, ".")
            else:         print("Ви не знаєте, скільки Вам років?")

            a = askfloat("Введення даних", "Який Ваш ріст у метрах?",
                parent=root, minvalue=0.0, maxvalue=2.5)
            if (a!=None): print("Ваш ріст ", a, " м.")
            else:         print("Ви не знаєте, якого Ви зросту?")</pre>
        </tt>
        <p>

        У ході його виконання буде таке.</p>
        <ol>
            <li>
                <p>
                Виведено вікно діалогу для введення рядка.</p>
                <center>
                    <img src="83.png">
                </center>
                <p>
                Довільний непорожній рядок буде сприйнято і виведено як ім'я користувача, інакше буде виведено у консоль: "Ви не знаєте свого імені?".</p>
            </li>
            <li>
                <p> 

                Виведено вікно діалогу для введення цілого значення.</p>
                <center>
                    <img src="90.png">
                </center>
                <p>
                При введенні хибних значень буде виведено відповідні повідомлення.</p>
                <center>
                    <img src="84.png">
                    <br>
                    <br>
                    <img src="85.png">
                    <br>
                    <br>
                    <img src="86.png">
                </center>
            </li>
            <li>
                <p> 

                Виведено вікно діалогу для введення запису десяткового дробу.</p>
                <center>
                    <img src="91.png">
                </center>
                <p>
                При введенні хибних значень буде виведено відповідні повідомлення.</p>
                <center>
                    <img src="87.png">
                    <br>
                    <br>
                    <img src="88.png">
                    <br>
                    <br>
                    <img src="89.png">
                </center>
            </li>
        </ol>
        <p>

            <a name="colorchooser"></a>
            <b>colorchooser</b>
             — 
            <i>модуль, що містить такі функцію askcolor, яка надає вікно діалогу для вибору кольору.</i>
        </p>
        <tt>
            <pre>
            from tkinter import *
            from tkinter.colorchooser import *
            root = Tk()
            c = askcolor(parent=root,initialcolor=(255,255,255))
            print(c)</pre>
        </tt>
        <center>
            <img src="92.png">
            <br>
            <br>
            <img src="93.png">
        </center>
        </li>
        </ol>
        <p>

            Внаслідок здійсненого вибору можна отримати таке виведення у консоль.
            <br>
            <br>
            <tt>
                 
                ((100.390625, 150.5859375, 200.78125), '#6496c8')
                <br>
                <br>
            </tt>

            <a name="ttk"></a>
            <font size=+3>
                <b>13. Розширення ttk</b>
            </font>
            <br>
            <br>

            <b>ttk</b>
             (themed tk) — 
            <i>розширення tcl/tk з новим набором віджетів, підтримкою тем і стилів оформлення.</i>
             Тому віджети ttk виглядають природніше в різних операційних системах. Починаючи з версій python 2.7 і 3.1.2 tkinter містить модуль для роботи з ttk.
            <br>
            <br>


            ttk містить віджети, які можна використати замість відповідних віджетів tk: 
            <i>Button, Checkbutton, Entry, Frame, Label, LabelFrame, Menubutton, PanedWindow, Radiobutton, Scale і Scrollbar.</i>
             Є кілька нових віджетів: 
            <i>Combobox, Notebook, Progressbar, Separator, Sizegrip и Treeview.</i>
            <br>
            <br>


            З точки зору програміста відмінність нових віджетів від старих полягає лише у тому, що віджетии ttk не мають опцій для конфігурування свого зовнішнього вигляду. Конфігурування зовнішнього вигляду віджетів ttk зійснюють через теми і стилі.
            <br>
            <br>


            ttk має 4 вбудовані теми: 
            <i>default, classic, alt, clam.</i>
             Додатково под Windows є теми 
            <i>winnative, xpnative i vista,</i>
             а під Mac OS X — 
            <i>aqua.</i>
            <br>
            <br>

            <b>Style</b>
             — 
            <i>клас для работи зі стилями й темами.</i>
             Саме цей клас потрібно використовувати для конфігурування зовнішнього вигляду віджетів ttk.
            <br>
            <br>

            <b>Основні методи класу Style</b>
        </p>
        <ul>
            <li>
                <p>
                    <b>configure</b>
                     — конфігурування зовнішнього вигляду віджетів. Має аргументи: назву стиля віджета і список опцій конфігурування. Наприклад,
                </p>
                <tt>
                    <pre>
                    style.configure("TButton",padding=6,relief="flat",background="#ccc")</pre>
                </tt>
            </li>
            <li>
                <p>

                    <b>map</b>
                     — конфігурування зовнішнього вигляду віджетів залежно від їхніх станів (active, pressed, disabled тощо). Має аргументи: назву стилю віджета і список параметрів конфігурації. Приклад використання:
                </p>
                <tt>
                    <pre>
                    style.map ( "C.TButton",
                        foreground = [( 'pressed', 'red'), ( 'active', 'blue')],
                        background = [( 'pressed', '! disabled', 'black'), ( 'active', 'white')]
                        )</pre>
                </tt>
            </li>
            <li>
                <p>

                    <b>lookup</b>
                     — повертає відповідну опцію конфігурації. Приклад використання:
                </p>
                <tt>
                    <pre>
                    style.lookup ( "TButton", "font")</pre>
                </tt>
            </li>
            <li>
                <p>

                    <b>layout</b>
                     — змінює схему (layout) віджета. Приклад використання:
                </p>
                <tt>
                    <pre>
                    style.layout ( "TMenubutton", [
                       ( "Menubutton.background", None),
                       ( "Menubutton.button", { "children":
                           [( "Menubutton.focus", { "children":
                               [( "Menubutton.padding", { "children":
                                   [( "Menubutton.label", { "side": "left", "expand": 1})]
                               })]
                           })]
                       }),
                    ])</pre>
                </tt>
            </li>
            <li>
                <p>

                    <b>element_create</b>
                     — cтворює новий елемент теми.
                </p>
            </li>
            <li>
                <p>
                    <b>element_names</b>
                     — повертає список елементів поточної теми.
                </p>
            </li>
            <li>
                <p>
                    <b>element_options</b>
                     — повертає список параметрів конфігурації, зазначеного в аргументі елемента.
                </p>
            </li>
            <li>
                <p>
                    <b>theme_create</b>
                     — cтворює нову тему, аргументи такі самі, що й у theme_settings (див. далі).
                </p>
            </li>
            <li>
                <p>
                    <b>theme_settings</b>
                     — конфігурує наявну тему. Має аргументи — назва теми і словник, ключами якого є назви стилів (TButton тощо), а значеннями — схеми (layout) відповідного стилю.
                </p>
            </li>
            <li>
                <p>
                    <b>theme_names</b>
                     — повертає список доступних тем.
                </p>
            </li>
            <li>
                <p>
                    <b>theme_use</b>
                     — змінює поточну тему на зазначену в аргументі.
                </p>
            </li>
        </ul>
        <p>

            <b>Віджет Combobox</b>
             призначено для відображення списку значень, їх вибору або зміни користувачем. У версії tk є схожий віджет Listbox. Різниця полягає у тому, що Combobox має можливість згортатися, а Listbox буде відображено завжди відкритим. Щоб відобразити Combobox з наперед заданими значеннями, досить зробити таке:
        </p>
        <tt>
            <pre>
            import tkinter as tk
            import tkinter.ttk as ttk
            root = tk.Tk ()
            frame = tk.Frame (root)
            frame.grid ()
            combobox = ttk.Combobox (frame, values=["ОДИН","ДВА","ТРИ"], height=3)
            #frame  - батьківський віджет, на його поверхні буде розташовано Combobox
            #values ​​- набір значень, розташованих у Combobox спочатку
            #height - висота списку. Якщо кількість елементів списку менше 11, то її можна не задавати.
            #         Якщо її не задано при кількості елементів, що перевищує 10, то праворуч буде смуга прокрутки.
            #         Якщо у поданому прикладі задати значення height, яке менше трьох, то праворуч буде смуга прокрутки.
            #         Але вона буде недоступна, а всі елементи буде відображено одночасно.
            combobox.set ("ОДИН")               # Combobox встановлено на значення ОДИН спочатку
            combobox.grid (column = 0, row = 0) # Combobox розташовано на формі
            root.mainloop ()</pre>
        </tt>
        <center>
            <img src="32.png">
        </center>
        <p>

            <b>Віджет Progressbar</b>
             відображає рівень завантаження. Має аргументи:
        </p>
        <ul>
            <li>
            батьківський віджет (у поданому прикладі root);</li>
            <li>
            length — довжина смуги.</li>
        </ul>
        <p>

            <b>Методи Progressbar</b>
            :
        </p>
        <ul>
            <li>
                <p>
                    <b>start</b>
                     — запускає нескінчений цикл завантаження. Крок довжиною 1 буде виконано у зазначений час (у мілісекундах);
                </p>
            </li>
            <li>
                <p>
                    <b>stop</b>
                     — зупиняє цикл завантаження;
                </p>
            </li>
            <li>
                <p>
                    <b>step</b>
                     — просуває процес завантаження на задану кількість кроків.
                </p>
            </li>
        </ul>
        <p>Приклад:</p>
        <tt>
            <pre>
            import tkinter as tk
            import tkinter.ttk as ttk
            root = tk.Tk ()
            pb = ttk.Progressbar (root, length = 100)
            pb.pack ()
            pb.start (100)
            root.mainloop ()</pre>
        </tt>
        <center>
            <video width="106" controls="" poster="29.png" loop='true' autoplay='true'>
                <source src="28.mp4" type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
            </video>
        </center>
        <p>

            <a name="examle"></a>
            <font size=+3>
                <b>14. Приклад: примітивний текстовий редактор</b>
            </font>
            .
        </p>
        <tt>
            <pre>
            from tkinter import *
            from tkinter.filedialog import *
            from tkinter.messagebox import *
            import fileinput
             
            class Window_blank:
              def __init__(self):
                main_menu = Menu(root)
                root.config(menu=main_menu)
                first_menu = Menu(main_menu)
                main_menu.add_cascade(label="Файл", menu=first_menu)
                first_menu.add_command(label="Відкрити",     command=self.open_file)
                first_menu.add_command(label="Зберегти як…", command=self.save_file)
                first_menu.add_command(label="Про програму", command=self.about)
                first_menu.add_command(label="Вихід",        command=self.close_win)
                self.txt = Text(root, width=45, height=15)
                self.txt.pack()
             
              def open_file(self):
                op = askopenfilename()
                try:
                  self.txt.delete(1.0, END)
                  for i in fileinput.input(op):
                    self.txt.insert(END, i)
                except:
                  pass
             
              def save_file(self):
                save_as = asksaveasfilename()
                try:
                  letter = self.txt.get(1.0, END)
                  f = open(save_as, "w")
                  f.write(letter)
                  f.close()
                except:
                  pass
             
              def close_win(self):
                if askyesno("Збереження файлу", "Зберегти дані?"):
                  self.save_file()
                  root.destroy()
                else:
                  root.destroy()
             
              def about(self):
                showinfo("Примітивний редактор", "Це лише приклад застосування tkinter")
             
            root = Tk()
            root.title("Примітивний редактор")
             
            obj_menu = Window_blank()
            root.mainloop()</pre>
        </tt>
        <p>
        Роботу цього коду проілюструємо такими малюнками.</p>
        <center>
            <img src="35.png">
            <br>
            <br>
            <img src="36.png">
            <br>
            <br>
            <img src="37.png">
            <br>
            <br>
            <img src="38.png">
            <br>
            <br>
            <img src="39.png">
            <br>
            <br>
            <img src="40.png">
            <br>
            <br>
            <img src="41.png">
            <br>
            <br>
            <img src="42.png">
            <br>
            <br>
            <img src="43.png">
            <br>
            <br>
            <img src="44.png">
            <br>
            <br>
            <img src="45.png">
            <br>
            <br>
            <img src="46.png">
            <br>
            <br>
            <img src="47.png">
        </center>

        <a name="links"></a>
        <font size=+3>
            <b>Посилання</b>
        </font>
        </p>
        <ol>
            <li>

                Tcl/Tk  
                <a href="http://www.tcl.tk/man" target="_blank">Manual Pages</a>
                .
            </li>
            <li>

                Tcl/Tk  
                <a href="http://www.tcl.tk/man/tcl8.5/" target="_blank">8.5 Manual</a>
                .
            </li>
            <li>
                <a href="http://www.tcl.tk/man/tcl8.5/TkCmd/" target="_blank">Перелік</a>
                 сторінок tcl.tk/man/tcl8.5/TclCmd.
            </li>
            <li>

                An 
                <a href="http://effbot.org/tkinterbook/" target="_blank">Introduction</a>
                 to Tkinter.
            </li>
            <li>
                <a href="https://ru.wikiversity.org/wiki/%D0%9A%D1%83%D1%80%D1%81_%D0%BF%D0%BE_%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B5_Tkinter_%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0_Python" target="_blank">Курс</a>
                 по библиотеке Tkinter языка Python.
            </li>
        </ol>
    </font>
</body>
</html>

